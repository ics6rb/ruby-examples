# frozen_string_literal: true

##
# Вспомогательная функиця для того, чтобы не дублировать код вывода результатов.
# На этот метод можно не писать тесты (что в данном примере с успехом и сделано).
# +points+:: +Array+ Массив, элементами которого являются пары "точка - флаг принадлежности графику функции".
def print_points(points)
  points.each do |coords, belongs|
    belongs_humanized = belongs ? 'принадлежит' : 'не принадлежит'
    puts "Точка с координатами #{coords} #{belongs_humanized} кривой."
  end
end

##
# Метод для проверки принадлежности массива точек в декартовых координатах графику функции f(x).
# Функция может передаваться в виде блока или в виде функционального объекта (Proc).
# Важно отметить, что хотя lambda и proc в Ruby имеют свои различия, тип у них один и тот же - Proc.
# +points+:: +Array+ Массив координат точек. Имеет вид [[x1, y1], [x2, y2], ...], где x и y имеют тип Float.
# +precision+:: +Integer+ Количество знаков после запятой, до которого будет округляться значение f(x).
# +function+:: +Proc+ Функция как Proc - один из вариантов передачи. Имеет значение по умолчанию,
# т.е. является необязательным параметром.
def neibr(points, precision, function = nil)
  # Проверка на корректность переданного массива: points.reject удаляет все элементы массива,
  # которые в свою очередь являются массивами с размерностью 2, то есть корректным представлением координаты точки.
  # Если после этой операции в новом массиве еще что-то осталось,
  # то это некорректные элементы и нужно кидать исключение.
  raise ArgumentError, 'Некорректный ввод: не все введенные значения являются парами координат.' unless
    points.reject { |x| x.is_a?(Array) && x.size == 2 }.empty?

  # .round(precision) вызывается потому, что математические функции в Ruby возвращают числа с плавающей точкой,
  # а в основной программе мы условились получать от пользователя числа с точностью два знака после запятой.
  points.map do |x, y|
    # block_given? - это встроенный метод, который обязательно нужно вызывать, ведь вызов yield без передачи блока
    # кинет исключение.
    if block_given?
      [[x, y], y == yield(x).round(precision)]
    elsif function.is_a? Proc
      [[x, y], y == function.call(x).round(precision)]
    # Если ни блок, ни Proc не были переданы, вернем для любой точки false.
    else
      [[x, y], false]
    end
  end
end
