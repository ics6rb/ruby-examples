# frozen_string_literal: true

require './main'

# По условию нужно ввести десять точек, поэтому можем хранить это количество в константе.
NUM_POINTS = 10
# Облегчим себе задачу и предложим пользователю вводить дроби с точностью два знака после запятой.
PRECISION = 2

# Тело выполнится только в том случае, если мы напишем ruby user.rb. Здесь это добавлено потому, что
# файл user.rb импортирован в тестах, и если бы не эта строчка, при запуске тестов нас бы просили вводить значения,
# в то время как нам нужно только импортировать костанту.
if $PROGRAM_NAME == __FILE__
  puts <<~STR
    Введите десять пар координат. Для разделения координат используйте пробел,
    пары отделяйте друг от друга нажатием клавиши ENTER.

    Если вы хотите ввести дробь, округлите ее до двух знаков после запятой.
  STR

  # NUM_POINTS.times - это способ повторить какое-то действие NUM_POINT раз,
  # а map позволяет нам получить в качестве результата выполнения массив,
  # а не число, как происходит по умолчанию.
  points = NUM_POINTS.times.map do
    gets # Читаем введенную пользователем строку.
      .split # Разбиваем ее по пробелам, получая тем самым массив.
      .map { |x| Float x, exception: false } # Для каждого элемента массива вызываем преобразование во Float, причем если оно невозможно, мы получим nil (так как написали exception: false).
      .compact # Удаляем из получившегося массива все nil, т.к. nil не округлится.
      .map { |x| x.round PRECISION } # Округляем оставшиеся числа до точности, с которой мы условились работать.
    # Побочным результатом двух последних операций является то, что теперь мы можем проверять валидность ввода пользователя
    # по количеству элементов массива points, которые сами являются массивами из двух элементов:
    # если все points - это массивы из двух элементов, то points целиком состоит из координат точек и все нормально,
    # если же есть хотя бы один элемент массива, который не удовлетворяет этому условию, то пользователь ввел что-то неправильно&
  end

  begin
    # Так как функция neibr кидает исключение, мы можем его перехватывать и выводить, а саму ошибку передавать в
    # сообщении исключения.
    cos_belongs = neibr(points, PRECISION) { |x| Math.cos x }
    # ->(x) { Math.sin x**2 } - это лямбда, а & превращает ее в элегантный блок.
    sin_belongs = neibr(points, PRECISION, &->(x) { Math.sin x**2 })
  rescue ArgumentError => e
    puts e
    exit 1 # Это значит, что если было исключение, программа дальше этой строки не пойдет и вернет код 1.
  end

  puts 'Для функции y = cos(x)'

  print_points cos_belongs

  puts 'Для функции y = sin(x^2)'

  print_points sin_belongs
end
