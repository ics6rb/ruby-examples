# 6_3 Функция, которая умеет одновременно работать и с блоком, и с Proc'ом

Составить метод `neibr` для проверки принадлежности точки плоскости с координатами `[x, y]` данной кривой `y = f(x)`. В основной программе использовать метод neibr для проверки принадлежности десяти различных точек кривым `y = coss(x)` и `y = sin(x^2)`.

## Установка зависимостей

```
bundle install
```

## Запуск

Код

```
ruby user.rb
```

Тесты

```
ruby test.rb
```

Линтер

```
rubocop
reek
```

## Почему работает?

Любая функция в Ruby принимает блок - произвольный кусок кода. Передать блок - это примерно то же самое, что передать 
одну функцию внутрь другой - блоки абсолютно так же, как и функции, могут принимать аргументы (или не принимать вовсе), и так же,
как и функции, возвращают значение.

Блоки появились в языке Ruby во многом из-за того, что любую функцию/метод можно вызывать без скобок, и интерпретатор принципиально не может отличить
вызов вида `foo(bar())` (где в `foo` передается результат вызова `bar`) от вызова `foo(bar)` (где в `foo` передается сама функция `bar`, чтобы `foo` могла ее вызвать внутри себя или передать вложенным функциям).
При этом иметь возможность передать функцию `bar` внутрь функции `foo` все еще нужно - как минимум для таких методов, как `sort, map, select` и т.д. Блоки решают эту проблему, и в целом являются мощной
концепцией передачи кода внутрь исполняющего метода.

Несмотря на то, что функции в Ruby принимают блоки по умолчанию, они не обязаны их вызывать и вообще хоть как-то использовать. Если игнорировать переданный блок, никакой ошибки не будет, он
просто не будет вызван (в обратную сторону не работает - вызывать непереданный блок нельзя). Для того, чтобы вызвать блок, используется ключевое слово `yield`. Несколько упрощая, его можно
представить себе как синоним для вызова функции - в таком вызове можно передавать аргументы (со скобками и без) или не передавать, никаких ограничений нет.
Фактически все зависит от того, какой именно блок и зачем автор функции ожидает получить от клиента. Например, в данной лабораторной работе блок - это зависимость `f(x)`.
Мы ожидаем, что передав в `yield` координату `x`, мы получим координату `y`, и строим свою функцию (и вызов блока) исходя из этого.

Все было бы прекрасно, если бы не одно но - [закон дырявых асбтракций](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D0%B8_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)#%D0%94%D1%8B%D1%80%D1%8F%D0%B2%D1%8B%D0%B5_%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D0%B8).
Любая, даже самая продуманная и хорошая абстракция, не способна предусмотреть всего и плохо работает в каких-то отдельно взятых случаях.

Так же получилось и с блоками - несмотря на все их удобство, блоки **НЕ являются объектами**, в отличие от, пожалуй, вообще всего в Ruby.
Таким образом, блоки **нельзя** записать в переменную. Если нас устраивает вариант, при котором `foo` вызывает `bar` внутри себя, это уже и не проблема.
Однако, если мы реализуем какую-то относительно хитрую логику, при которой, к примеру, `foo` вызывает внутри себя одну из функций `f1`, `f2` или `f3`, и вот они-то используют `bar`,
то блоки нам абсолютно ничем и никак не помогут от слова совсем.

Для наглядности напишем простую реализацию на JS:

```js
function f1(bar) {
    console.log('F1');
    console.log(bar());
}

function f2(bar) {
    console.log('F2');
    console.log(bar());
}

function f3(bar) {
    console.log('F3');
    console.log(bar());
}

function foo(x, bar) {
    if (x > 0) {
        f1(bar);
    } else if (x === 0) {
        f2(bar);
    } else {
        f3(bar);
    }
}

foo(1, () => console.log('BAR'));
```

Используя только лишь блоки, мы не сможем воспроизвести то же самое поведение на Ruby. Однако наивно было бы полагать, что такой код невоспроизводим принципиально: это, конечно же,
возможно, единственное, что языку потребовалось ввести еще одну абстракцию.

Итак, если мы хотим передавать код, но не можем записывать блок в переменную, давайте создадим объект (который, само собой, можно записывать в переменную), и в его конструктор
передадим блок! Так появились функциональные объекты, procedural objects или просто `Proc`. Сейчас мы не будем подробно рассматривать все варианты создания такого объекта, 
не будем упоминать про разновидность `Proc`'а под названием `lambda` и отличия одного от другого, в данном случае нам важен просто факт существования такого объекта.

Код из сниппета выше можно переписать на Ruby как

```ruby
def f1(pr)
  puts 'F1'
  pr.call
end

def f2(pr)
  puts 'F2'
  pr.call
end

def f3(pr)
  puts 'F3'
  pr.call
end

def foo(x, bar)
  if x.positive?
    f1(bar)
  elsif x.zero?
    f2(bar)
  else
    f3(bar)
  end
end

foo(1, Proc.new {puts 'BAR'})
```

По большому счету мы просто "обернули" блок в объект, записали в переменную, после чего можем передавать его куда и как угодно.

Небольшой итог:

1. В любую функцию можно передавать блок и вызывать его с использованием ключевого слова `yield`.
2. Любой блок можно обернуть в объект типа `Proc` и передавать как обычную переменную.

Блоки могут быть переданы как неявно (ничего не нужно делать, кромы вызова `yield` в нужном месте с нужными параметрами), 
так и явно. Явная передача блока выглядит как

```ruby
def foo(a, b, c, &block)
end
```

`block` - это имя переменной, в которой будет содержаться блок, и оно, само собой, может быть любым. Главное, чтобы перед этим именем
стоял символ `&`, обозначающий, что мы ожидаем от интерпретатора преобразования блока в переменную с этим именем.

Функция принимает **только один блок** и **только последним параметром**, таким образом, записи вида

```ruby
def foo1(a, b, c, &block1, &block2)
end

def foo2(a, &block, b, c, &block)
end
```

**невалидны**.

Блок можно записать в переменную только через преобразование в `Proc`, и Ruby **умеет это делать автоматически**. Если немного углубиться в детали
реализации, то это делается с помощью метода [`Symbol#to_proc`](https://borgs.cybrilla.com/tils/symbol-to-proc-in-ruby/#:~:text=Yes%20it%20adds%20the%20numbers%2C%20but%20how%20does%20this%20work%3F&text=to_proc%20returns%20a%20simple%20Proc,and%20is%20much%20more%20sophisticated.).

Настал торжественный и волнующий момент, когда мы подошли к сути - в лабораторной работе требуется написать **одну** функцию, которая будет способна принимать и блок, и `Proc`.
**& ВООБЩЕ НИ В КАКОМ ВИДЕ ТУТ НЕ ПОДХОДИТ**. Что же подходит - [см. код](main.rb).
