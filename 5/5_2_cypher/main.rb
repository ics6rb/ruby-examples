# frozen_string_literal: true

# Работаем только с русским алфавитом.
# Под базой в данном случае понимается количество букв в алфавите, чтобы делать циклический сдвиг, 'я' + 2 = 'Б'.
# Также исходя из особенностей построения кодировок подразумевается, что алфавит состоит из строчных и прописных букв.
ALPHABET_BASE = ('А'..'я').to_a.size
# Код первой буквы алфавита.
BASE_SHIFT = 'А'.ord

##
# Вспомогательная функция для печати результата.
# +strings+:: +Array+ Массив строк для печати.
def print_strings(strings)
  strings.each do |string|
    puts string
  end
end

##
# Функция, которая генерирует ключ для строки: циклически повторяет строку ключа для каждой буквы
# строки, а для не букв ставит 0, то есть оставляет их без изменений.
# +string+:: +String+ Строка, для которой необходимо сгенерировать ключ.
# +key+:: +String+ Строка ключа, которую необходимо расширить в соответствии с описанными выше правилами.
def generate_key_for_string(string, key)
  key_cycle = key.each_char.map(&:to_i).cycle
  string.each_char.map { |char| (key_cycle.next if /[А-Яа-я]/ =~ char) || 0 }
end

##
# Функция, которая применяет преобразование к строке: так как зашифрование и расшифрование делаются одинаково
# за исключением одной операции - прибавления или вычитания сдвига соотвтетсвенно, все остальные операции вынесены
# в отдельную функцию и переиспользуются.
# +string+:: +String+ Строка, которую необходимо зашифровать или расшифровать.
# +key+:: +String+ Ключ.
# +operation+:: +Proc+ Proc с операцией. Принимает в качестве аргумента код текущего символа (от 0 до 63) и текущий сдвиг.
def apply_key_to_string(string, key, &operation)
  # Расширяем ключ до длины строки с учетом пробелов и знаков препинания.
  key_for_string = generate_key_for_string(string, key)
  string
    .unpack('U*') # Превращаем строку в массив кодом символов. U* значит Unicode, т.к. мы работаем с русскими буквами.
    .map { |char_code| (char_code - BASE_SHIFT).abs } # Для того, чтобы циклический сдвиг по модулю алфавита работал, нам нужно, чтобы коды символов начиналис с нуля, а реально они будут начинаться с кода А. Поэтому вычитаем код А.
    .zip(key_for_string) # С этого момента мы итерируемся одновременно по двум массивам - по строке и ключу.
    .map { |char_code, shift| operation.call(char_code, shift) % ALPHABET_BASE } # Вызываем операцию зашифрования/расшифрования.
    .map { |char_code| char_code + BASE_SHIFT } # Восстанавливаем порядок вещей и прибавляем код А.
    .pack('U*') # Превращаем массив кодов символов в строку, не забыв указать, что это Unicode.
end

def encrypt(string, key)
  apply_key_to_string(string, key) { |char_code, shift| char_code + shift }
end

def decrypt(string, key)
  apply_key_to_string(string, key) { |char_code, shift| char_code - shift }
end
