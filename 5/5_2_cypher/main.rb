# frozen_string_literal: true

# Работаем только с русским алфавитом.
# Под размером в данном случае понимается количество всех букв в алфавите, которое нужно для взятия остатка от деления
# при взятии остатка от деления: 'я' + 2 = 'Б'.
# Исходя из особенностей построения кодировок подразумевается, что алфавит состоит из строчных и прописных букв.
ALPHABET = ('А'..'я').freeze # Метод freeze используется для того, чтобы сделать объект неизменяемым,
# т.к. он используется в качестве константы.
ALPHABET_CODES = ALPHABET.to_a.join.unpack('U*') # Превращает буквы в массив кодов символов, которые нам понадобятся
# в дальнейшем, чтобы фильтровать знаки препинания
ALPHABET_SIZE = ALPHABET.to_a.size
# Код первой буквы алфавита, который используется как сдвиг для корректного взятия остатка от деления.
BASE_SHIFT = 'А'.unpack1('U')

##
# Вспомогательная функция для печати результата.
# +strings+:: +Array+ Массив строк для печати.
def print_strings(strings)
  strings.each do |string|
    puts string
  end
end

##
# Функция, которая генерирует ключ для строки: циклически повторяет строку ключа для каждой буквы
# строки, а для не букв ставит 0, то есть оставляет их без изменений.
# +string+:: +String+ Строка, для которой необходимо сгенерировать ключ.
# +key+:: +String+ Строка ключа, которую необходимо расширить в соответствии с описанными выше правилами.
def generate_key_for_string(string, key)
  key_cycle = key.each_char.map(&:to_i).cycle
  string.each_char.map { |char| (key_cycle.next if /[А-Яа-я]/ =~ char) || 0 }
end

##
# Функция, которая применяет преобразование к строке: так как зашифрование и расшифрование делаются одинаково
# за исключением одной операции - прибавления или вычитания сдвига соотвтетсвенно, все остальные операции вынесены
# в отдельную функцию и переиспользуются.
# +string+:: +String+ Строка, которую необходимо зашифровать или расшифровать.
# +key+:: +String+ Ключ.
# +operation+:: +Proc+ Proc с операцией. Принимает в качестве аргумента код текущего символа (от 0 до 63) и текущий сдвиг.
def apply_key_to_string(string, key, &operation)
  # Расширяем ключ до длины строки с учетом пробелов и знаков препинания.
  key_for_string = generate_key_for_string(string, key)
  string
    .unpack('U*') # Превращаем строку в массив кодов символов. U* значит ВСЕ СИМВОЛЫ в Unicode, т.к. мы работаем с русскими буквами (можно еще написать просто U, тогда будет только самый первый).
    .map { |char_code| ALPHABET_CODES.include?(char_code) ? (char_code - BASE_SHIFT).abs : -char_code } # Для того, чтобы циклический сдвиг по модулю алфавита работал, нам нужно, чтобы коды символов начиналис с нуля, а реально они будут начинаться с кода А. Поэтому вычитаем код А. -char_code - это грязный хак, который позволит на следующих шагах не трогать все, что не является русской буквой (например, знаки препинания и пробелы).
    .zip(key_for_string) # "Цепляем" ключ: с этого момента мы итерируемся одновременно по двум массивам - по строке и ключу.
    .map { |char_code, shift| char_code >= 0 ? operation.call(char_code, shift) % ALPHABET_SIZE : char_code } # Вызываем операцию зашифрования/расшифрования только для букв русского алфавита.
    .map { |char_code| char_code >= 0 ? char_code + BASE_SHIFT : -char_code } # Восстанавливаем порядок вещей и прибавляем код А, а коды тех символов, которые мы "отбрасывали" путем смены знака, делаем снова положительными для корректного восстановления строки.
    .pack('U*') # Превращаем массив кодов символов обратно в строку, не забыв указать, что это Unicode.
end

def encrypt(string, key)
  apply_key_to_string(string, key) { |char_code, shift| char_code + shift }
end

def decrypt(string, key)
  apply_key_to_string(string, key) { |char_code, shift| char_code - shift }
end
